<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Alpaca Quote Heatmap</title>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <style>
      :root {
        color-scheme: light dark;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }

      body {
        margin: 1.5rem;
        background: #0b0d17;
        color: #f1f5f9;
      }

      header {
        margin-bottom: 1.5rem;
      }

      h1 {
        font-size: 1.75rem;
        margin: 0 0 0.25rem 0;
      }

      p {
        margin: 0.35rem 0;
      }

      #heatmap {
        width: 100%;
        max-width: 960px;
        margin-top: 1.5rem;
      }

      .status {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 1rem;
        font-size: 0.9rem;
      }

      .error {
        color: #f97316;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Alpaca Quote Heatmap</h1>
      <p>
        实时请求 Alpaca 最新报价并绘制相对涨跌幅的热力图。绿色表示上涨，红色表示下跌。默认轮询间隔
        {{ poll_interval_seconds }} 秒，可在 URL 查询参数中调整股票列表（例如
        <code>?symbols=AAPL&amp;symbols=GOOGL&amp;symbols=MSFT</code>）。
      </p>
      <div class="status">
        <span id="last-update">等待数据…</span>
        <span id="status-message"></span>
      </div>
    </header>

    <div id="heatmap"></div>

    <script>
      const symbols = {{ symbols | tojson }};
      const pollIntervalSeconds = {{ poll_interval_seconds }};
      const maxPoints = 40;
      const priceHistory = Object.fromEntries(symbols.map((symbol) => [symbol, []]));
      const basePrices = Object.fromEntries(symbols.map((symbol) => [symbol, null]));
      const timestamps = [];

      const lastUpdateEl = document.getElementById("last-update");
      const statusMessageEl = document.getElementById("status-message");

      function formatTime(isoString) {
        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return isoString;
        }
        return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
      }

      function trimHistory() {
        if (timestamps.length > maxPoints) {
          timestamps.shift();
          symbols.forEach((symbol) => priceHistory[symbol].shift());
        }
      }

      function computeHeatmapMatrix() {
        return symbols.map((symbol) => {
          const base = basePrices[symbol];
          return priceHistory[symbol].map((price) => {
            if (base == null || price == null) {
              return null;
            }
            return ((price - base) / base) * 100;
          });
        });
      }

      function updateHeatmap() {
        const zMatrix = computeHeatmapMatrix();
        const heatmapData = [
          {
            z: zMatrix,
            x: timestamps.map((iso) => formatTime(iso)),
            y: symbols,
            type: "heatmap",
            colorscale: [
              [0, "#7f1d1d"],
              [0.5, "#111827"],
              [1, "#10b981"],
            ],
            zmid: 0,
            zsmooth: "best",
            colorbar: {
              title: "% Δ",
              titleside: "right",
            },
          },
        ];

        const layout = {
          margin: { l: 80, r: 30, t: 10, b: 50 },
          xaxis: {
            title: "时间",
            tickangle: -45,
          },
          yaxis: {
            title: "股票",
            automargin: true,
          },
        };

        const config = {
          responsive: true,
          displaylogo: false,
        };

        Plotly.react("heatmap", heatmapData, layout, config);
      }

      function recordQuotes(quotes) {
        const fetchTimestamp = new Date().toISOString();
        timestamps.push(fetchTimestamp);

        symbols.forEach((symbol) => {
          const quote = quotes[symbol];
          if (!quote) {
            priceHistory[symbol].push(null);
            return;
          }

          const price =
            typeof quote.ask_price === "number" && quote.ask_price > 0
              ? quote.ask_price
              : typeof quote.bid_price === "number" && quote.bid_price > 0
              ? quote.bid_price
              : null;

          priceHistory[symbol].push(price);
          if (basePrices[symbol] == null && price != null) {
            basePrices[symbol] = price;
          }
        });

        trimHistory();
        updateHeatmap();
      }

      async function fetchQuotes() {
        try {
          const params = new URLSearchParams();
          symbols.forEach((symbol) => params.append("symbols", symbol));

          const response = await fetch(`/quotes?${params.toString()}`);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const payload = await response.json();
          recordQuotes(payload.quotes || {});
          const latestTimestamp = timestamps[timestamps.length - 1];
          lastUpdateEl.textContent = `最近更新时间：${formatTime(latestTimestamp)}`;
          statusMessageEl.classList.remove("error");
          statusMessageEl.textContent = "";
        } catch (error) {
          statusMessageEl.textContent = `数据请求失败：${error.message}`;
          statusMessageEl.classList.add("error");
        }
      }

      function startPolling() {
        fetchQuotes();
        setInterval(fetchQuotes, pollIntervalSeconds * 1000);
      }

      startPolling();
    </script>
  </body>
</html>
